# -*- coding: utf-8 -*-
"""Projeto1_GrupoK.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fUJOKn248y-e2yfysTJpeuN4MIkuN7SS

<h1> <b> Perception and Mapping 22/23 </b> </h1> 
<h2> <b> Project 1 </b> </h2> 

Made by:
  - <h4> Tiago Pereira Correia up201806248@up.pt </h4>
  - <h4> João Nuno Leitão up201806619@up.pt </h4>

<br>
FEUP, 1st Semester, Oct.2022

<h3> Setup and Imports </h3>
"""

pip install celluloid

import numpy as np
from numpy import * 
import matplotlib.pyplot as plt
import pandas as pd
import sys
from scipy import signal
from scipy.signal import argrelextrema #meio que nao

from celluloid import Camera
from IPython.display import HTML



"""<h3> Getting Data set </h3>"""

file = 'data.csv'
data = pd.read_csv(file, delimiter=';', index_col=None, header=None,comment='#', na_values=['Nothing'])

data.head(61)

"""<h3> Separation of the data set in different columns. First 6 columns separated from the rest (Px, Py, Theta, d_x, d_y, d_theta) and the next 61 columns Lidar measurements (Lidar_range)."""

Lidar_range = data.iloc[:, np.arange(6,67,1)].values
t=1*10

px = data[0].values
py = data[1].values
th = data[2].values

x_delta=data[3].values
y_delta=data[4].values
th_delta=data[5].values

angle = np.linspace(-30, 30, 61)

"""---
<h2> <b>Task 1</b> </h2>

<h3>1.1 - Detect if exist corner in every Lidar measurement and plot it </h3>

---
"""

corner = []
residuals1 = float
residuals2 = float

for t in range(len(Lidar_range)):  
  x_o, y_o = [], []
  corner_prob = []
  vector1 = []
  vector2 = []
  for i in range(len(angle)):
    if Lidar_range[t][i] > 0:
      x_o.append(Lidar_range[t][i]*np.cos(angle[i]/180*np.pi))
      y_o.append(Lidar_range[t][i]*np.sin(angle[i]/180*np.pi))    
      

  for j in range(5,len(angle)-5) :#range(2,len(angle)-2):
    x_1 = x_o[:j]
    y_1 = y_o[:j]
    x_2 = x_o[j:]
    y_2 = y_o[j:]

    #print(j,len(x_2),len(x_1),len(x_o))
    dy = abs(y_o[j]-y_o[0])
    dx = abs(x_o[j]-x_o[0])
    if dx>dy:
      coefs1,resid1, rank, singular_values, rcond = np.polyfit(x_1,y_1,1,full=1)
      #print(resid1)
      residuals1f = resid1[0]
      vals1=np.polyval(coefs1,x_1)
      plt.plot(x_1,vals1)
      vector1.append([1,coefs1[0]])
      #print('1 horizontal')
    else:
      coefs1,resid1, rank, singular_values, rcond = np.polyfit(y_1,x_1,1,full=1)
      #print(resid1)
      residuals1f = resid1
      vals1=np.polyval(coefs1,y_1)
      plt.plot(vals1,y_1)
      vector1.append([coefs1[0],1])
      #print('1 vertical')

    dy = abs(y_o[-1]-y_o[j])
    dx = abs(x_o[-1]-x_o[j])
    if dx>dy:
      coefs2,resid2, rank, singular_values, rcond = np.polyfit(x_2,y_2,1,full=1)
      residuals2f = resid2
      vals2=np.polyval(coefs2,x_2)    
      plt.plot(x_2,vals2)
      vector2.append([1,coefs2[0]])
      #print('2 horizontal')
    else:

      coefs2,resid2, rank, singular_values, rcond = np.polyfit(y_2,x_2,1,full=1)
      residuals2f = resid2
      vals2=np.polyval(coefs2,y_2)
      plt.plot(vals2,y_2)
      vector2.append([coefs2[0],1]) 
      #print('2 vertical')
    #print(residuals1f,residuals2f)
    corner_prob.append(residuals2f+residuals1f)
  
    
    #print(corner_prob[j-2])
  
  max_prob = min(corner_prob)
  max_prob_index = corner_prob.index(max_prob)

  print(np.cross(vector1[max_prob_index],vector2[max_prob_index]))

  if(abs(np.cross(vector1[max_prob_index],vector2[max_prob_index]))>0.95):
    corner.append([x_o[max_prob_index+5],y_o[max_prob_index+5]])
    
  else:
    corner.append([0,0])


  
  plt.scatter(x_o, y_o, color='b')
  plt.scatter(corner[t][0],corner[t][1],color='r',zorder=1000)
  plt.title('2D Map');
  plt.show()

print(corner)

"""<h3> Corner Detection function and update </h3>"""

def detect_corner(lidar_data):
  corner = []
  residuals1 = float
  residuals2 = float
  x_o, y_o = [], []
  corner_prob = []
  vector1 = []
  vector2 = []
  for i in range(len(angle)):
    if lidar_data[i] > 0:
      x_o.append(lidar_data[i]*np.cos(angle[i]/180*np.pi))
      y_o.append(lidar_data[i]*np.sin(angle[i]/180*np.pi))    
      

  for j in range(5,len(angle)-5) :
    x_1 = x_o[:j]
    y_1 = y_o[:j]
    x_2 = x_o[j:]
    y_2 = y_o[j:]

    dy = abs(y_o[j]-y_o[0])
    dx = abs(x_o[j]-x_o[0])
    if dx>dy:
      coefs1,resid1, rank, singular_values, rcond = np.polyfit(x_1,y_1,1,full=1)
      residuals1f = resid1[0]
      vector1.append([1,coefs1[0]])
    else:
      coefs1,resid1, rank, singular_values, rcond = np.polyfit(y_1,x_1,1,full=1)
      residuals1f = resid1
      vector1.append([coefs1[0],1])

    dy = abs(y_o[-1]-y_o[j])
    dx = abs(x_o[-1]-x_o[j])
    if dx>dy:
      coefs2,resid2, rank, singular_values, rcond = np.polyfit(x_2,y_2,1,full=1)
      residuals2f = resid2
      vector2.append([1,coefs2[0]])
    else:
      coefs2,resid2, rank, singular_values, rcond = np.polyfit(y_2,x_2,1,full=1)
      residuals2f = resid2
      vector2.append([coefs2[0],1]) 

    corner_prob.append(residuals2f+residuals1f)
  
    
    #print(corner_prob[j-2])
  
  max_prob = min(corner_prob)
  max_prob_index = corner_prob.index(max_prob)

  if(abs(np.cross(vector1[max_prob_index],vector2[max_prob_index]))>0.98):
    corner.append([x_o[max_prob_index+5],y_o[max_prob_index+5]])
    
  else:
    return -1
  return corner

def to_polar(x,y):
  r=np.sqrt(x**2+y**2)
  ang=np.arctan2(y, x)
  return(ang/np.pi*180,r)

def corner_to_index(corner_coord):
  corner_polar = to_polar(corner_coord[0],corner_coord[1])
  index_corner=round(corner_polar[0])+30
  return index_corner

"""<h4> Example of corner detection </h4>"""

#Example of detection

corner_ex=detect_corner(Lidar_range[5])
if corner_ex != -1:
  x_aux=corner_to_index(corner_ex[0])
  print(x_aux)
else:
  print("Not an corner")

"""<h3> 1.2 - Using the exact location of the robot build a map with the four corners of the room </h3>"""

#Update corner positioin (x,y) to polar coordinates and find the index of the corner in Lidar_range

index_corner = []

for t in range(len(Lidar_range)):

  if ((corner[t][0] != 0) and (corner[t][1] != 0)):
    corner_polar = to_polar(corner[t][0],corner[t][1])
    index_corner.append(round(corner_polar[0])+30)
  else:
    index_corner.append(-1)

#Plot the map and the known corners

border_x, border_y = [], []
corner_x, corner_y = [], []

for t in range(len(Lidar_range)):  
  for i in range(len(angle)):
    if Lidar_range[t][i] > 0:
      border_x.append(px[t]+Lidar_range[t][i]*np.cos(th[t] + angle[i]/180*np.pi))
      border_y.append(py[t]+Lidar_range[t][i]*np.sin(th[t] +angle[i]/180*np.pi))    
      
for t in range(len(Lidar_range)):
  if (index_corner[t]!= -1):
    corner_x.append(px[t]+Lidar_range[t][index_corner[t]]*np.cos(th[t] + angle[index_corner[t]]/180*np.pi))
    corner_y.append(py[t]+Lidar_range[t][index_corner[t]]*np.sin(th[t] + angle[index_corner[t]]/180*np.pi))
        
fig, ax = plt.subplots(figsize=(7,7))

ax.axis('equal')
plt.xlim(-3,18)
plt.ylim(-5,15)
#plt.plot(px[t], py[t], 'g.', ms=15)  #position of the robot
plt.grid()

plt.scatter(border_x, border_y, color='b')
plt.scatter(corner_x, corner_y, color='r')
plt.title('2D Map');
plt.show()

"""<h2> <b>Task 2</b> </h2>

<h3> 2.1 - Considering that the initial pose of the robot is known (pose at the initial instant) design and implement
a procedure to estimate in real time the evolution of the robot based only on the variations of the robot
pose. </h3>
"""

px_estimated, py_estimated = [], []   #Position estimation with delta_x and delta_y
px_evolution, py_evolution = [], []   #Real Position evalution

px_estimated.append(px[0])
py_estimated.append(py[0])

px_evolution.append(px[0])
py_evolution.append(py[0])

for t in range(len(Lidar_range)):  
  if Lidar_range[t][i] > 0:
    px_estimated.append(px_estimated[t] + x_delta[t])
    py_estimated.append(py_estimated[t] + y_delta[t])
    
    px_evolution.append(px[t])
    py_evolution.append(py[t])

    erro_x=px_estimated[t]-px_evolution[t]
    erro_y=py_estimated[t]-py_evolution[t]
    print("Erro: ", erro_x, erro_y)
  
  fig, ax = plt.subplots(figsize=(7,7))
  ax.axis('equal')
  plt.xlim(-3,18)
  plt.ylim(-5,15)
  plt.plot(px_evolution, py_evolution, 'g.', ms=13, label="Real Position")  #Real Position of the robot
  plt.grid()
  plt.scatter(px_estimated, py_estimated, color='b', label="Estimated Position based only on deltas") #Estimated Position of the robot
  plt.title('2D Map');
  plt.legend(bbox_to_anchor =(0.5,-0.17), loc='lower center')
  plt.show()

"""<h2> <b>Task 3</b> </h2>

<h3>Design and implement a system that processes the variations of the robot pose and also the LIDAR
readings to estimate in real time the pose fo the robot as well as the locations of the rooms corners.
</h3>
"""

def check_known_corner(x_corner, y_corner, known_cor):
  threshold = 3

  if(len(known_cor) == 0):
    known_cor.append([x_corner, y_corner])
    return 0
  else:
    for i in range(1, len(known_cor)+1):
      if  ( abs(known_cor[i-1][0] - x_corner) < threshold) and ( abs(known_cor[i-1][1] - y_corner) < threshold):
        known_cor[i-1][0]=x_corner
        known_cor[i-1][1]=y_corner
        return i
      else:
        return 0

def kf_predict(X, P, Q, U): 
  """      
    X : The mean state estimate of the previous step (k−1) - shape(m,1) 
    P : The state covariance of previous step (k−1) - shape(m,m) 
    Q : The process noise covariance matrix - shape(m,m) 
    U : The control input - shape(q,1)
  """ 
  X = X + U 
  P = P + Q 
  return(X,P)

def kf_update(X, P, Y, H, R, HX): 
  """      
    K  : the Kalman Gain matrix 
    IS : the Covariance or predictive mean of Y  
  """
  YHX = Y - HX
  while(YHX[1] > np.pi):
    YHX[1]=YHX[1] - 2*np.pi
  while(YHX[1] < -np.pi):
    YHX[1]=YHX[1] + 2*np.pi

  IS = H @ P @ H.T + R  
  K = P @ H.T @ np.linalg.inv(IS) 
  X = X + K @ YHX 
  P = P - K @ IS @ K.T  
  return (X,P)

#camera=Camera(fig) 

# Initial state
X=np.array(   [ [ px[0] ] ,
                [ py[0] ] ,
                [ th[0] ]  ] )

# Initial covariance
P = np.array( [ [ 0.0, 0.0, 0.0 ] ,
                [ 0.0, 0.0, 0.0 ] ,
                [ 0.0, 0.0, 0.0 ] ] )

# Meas matrix 
H = np.array( [ [ 1.0, 0.0, 0.0 ] ,
                [ 0.0, 1.0, 0.0 ] ] )       

# Meas noise
sigma_o = 5;
R = np.array( [ [ sigma_o**2, 0.0 ] ,
                [ 0.0, sigma_o**2 ] ] ) 

# Process noise
sigma_a = 4;
Q = np.array( [ [ sigma_a**2, 0.0, 0.0 ] ,
                [ 0.0, sigma_a**2, 0.0 ] ,
                [ 0.0, 0.0, sigma_a**2 ] ] ) 
# Meas
Z=np.array(   [ [ 0 ] ,
                [ 0 ]  ] )

U=np.array(   [ [ px[0] ] ,
                [ py[0] ] ,
                [ th[0] ]  ] )

# Kalman Filter loop:
 #Previous state
 #New Predicted state
 #Calculate Kalman Gain and Measured Data (Y)
 #Update Process and state Matrix


known_corners = []
num_features=0
robot_x, robot_y = [], []
x_corner, y_corner = [], []
border_x, border_y =[], []
all_x_corners, all_y_corners= [], []


for t in range(len(Lidar_range)):

  for i in range(len(angle)):

    border_x.append(px[t]+Lidar_range[t][i]*np.cos(th[t] + angle[i]/180*np.pi))
    border_y.append(py[t]+Lidar_range[t][i]*np.sin(th[t] +angle[i]/180*np.pi))

    possible_corner=detect_corner(Lidar_range[t])

    if (possible_corner != -1) and (corner_to_index(possible_corner[0]) == i):

      x_corner = X[0][0] + Lidar_range[t][i]*np.cos(X[2][0] + angle[i]/180*np.pi)
      y_corner = X[1][0] + Lidar_range[t][i]*np.sin(X[2][0] + angle[i]/180*np.pi)
      
      corner = np.array([[x_corner],[y_corner]])
      index_corner = check_known_corner(x_corner, y_corner, known_corners)


      if (index_corner==0):

          X=np.append(X,corner,axis=0)

          empty=np.zeros((2,1))
          U = np.append(U,empty,axis=0)

          tile_r=np.zeros((P.shape[0],2))
          tile_d=np.zeros((2,P.shape[0]+2))
          P = np.append(P,tile_r,axis=1)
          P = np.append(P,tile_d,axis=0)
          P[ P.shape[0]-2,P.shape[1]-2 ] = P[0][0]
          P[ P.shape[0]-1,P.shape[1]-1 ] = P[1][1]

          tile_r=np.zeros((Q.shape[0],2))
          tile_d=np.zeros((2,Q.shape[0]+2))
          Q = np.append(Q,tile_r,axis=1)
          Q = np.append(Q,tile_d,axis=0)
          Q[ Q.shape[0]-2,Q.shape[1]-2 ] = sigma_a**2
          Q[ Q.shape[0]-1,Q.shape[1]-1 ] = sigma_a**2

          known_corners.append([x_corner, y_corner])
          all_x_corners.append([x_corner])
          all_y_corners.append([y_corner])

          num_features = num_features + 1 

      else:
        feat = known_corners[index_corner-1]

        x_corner=feat[0]
        y_corner=feat[1]
          
        Z=np.array( [ [ Lidar_range[t][i] ] ,
                      [ np.deg2rad(i-30) ] ] )

        dist_corner =np.sqrt( (x_corner - X[0][0])**2 + (y_corner - X[1][0])**2 )
        ang_corner=np.arctan2( (y_corner - X[1][0]), (x_corner - X[0][0]) ) - X[2][0]  

        HX = np.array( [ [ dist_corner] , 
                         [ ang_corner ] ] )

        dr_dx = -(x_corner - X[0][0])/dist_corner
        dr_dy = -(y_corner - X[1][0])/dist_corner
        dr_theta = 0
        dfi_dx = (y_corner - X[1][0])/(dist_corner**2)
        dfi_dy = -(x_corner - X[0][0])/(dist_corner**2)
        dfi_theta = -1

        H = np.array( [ [ dr_dx, dr_dy, dr_theta ] , 
                        [ dfi_dx, dfi_dy, dfi_theta] ] )

        #values of the feature
        f11=  (x_corner - X [0][0]) / dist_corner
        f12=  (y_corner - X [1][0]) / dist_corner
        f21= -(y_corner - X[1][0]) / dist_corner
        f22=  (x_corner - X[0][0]) / dist_corner
                
        F= np.array([[f11,f12],  
                    [f21,f22]])
        
        empty=np.zeros((2,2))
        
        for i in range(num_features):
          if(i+1 != index_corner):
            H = np.append(H,empty,axis=1)
          else:
            H = np.append(H,F,axis=1)
            

        (X, P) = kf_update(X, P, Z, H, R, HX) 

    robot_x.append(X[0][0])
    robot_y.append(X[1][0])
    
  U[0][0]=x_delta[t]
  U[1][0]=y_delta[t]
  U[2][0]=th_delta[t]

  (X, P) = kf_predict(X, P, Q, U)


  fig, ax = plt.subplots(figsize=(7,7))
  ax.axis('equal')
  plt.xlim(-3,18)
  plt.ylim(-5,18)
  plt.plot(px, py, 'g.', ms=10)  #Real position of the robot
  plt.plot(robot_x, robot_y, 'r.', ms=10)  #position estimated of the robot using a Kalman Filter
  plt.scatter(border_x, border_y, color='b')
  plt.scatter(x_corner, y_corner, color='k')
  plt.scatter(all_x_corners, all_y_corners, color='y')
  plt.scatter(px_estimated, py_estimated, color='grey') #Estimated Position based only on deltas
  plt.grid()
  plt.title('2D Map')
  plt.show()

#video = camera.animate(interval = 100, blit=False, repeat=False)

#HTML(video.to_html5_video())

"""---

.

.

.

.

<h1> Extras (Tentativas interessantes)
"""

from scipy.signal import savgol_filter
from statistics import mean
Lidar_range = data.iloc[:, np.arange(6,67,1)].values
print(Lidar_range)
px = data[0].values
py = data[1].values



t=1*10 #1sec times number of samples/second

angle = np.linspace(-30, 30, 61)

for i in range(len(Lidar_range)):
  plt.figure()
  plt.scatter(angle, Lidar_range[i], color='b')
  plt.title('Lidar measurements')
  plt.ylabel('r [m]')
  plt.xlabel('$beta$ [degree]')
  plt.grid();
  yhat = savgol_filter(Lidar_range[i], 51, 10)
  yhat2 = savgol_filter(yhat, 51, 4)
  plt.plot(angle,yhat2, color='red')
  locals_maximum=argrelextrema(yhat2, np.greater)
# em desenvolvimento


  coefs5deg = np.polyfit(angle,yhat2,4)
  values5deg = np.polyval(coefs5deg,angle)
  plt.plot(angle,values5deg,color='green')
  print(coefs5deg)

  coefsder = np.polyder(coefs5deg,1)
  valuesder = np.polyval(coefsder,angle) * 10
  plt.plot(angle,valuesder,color='pink')
  #plt.show()
  
 
  max_dist = max(Lidar_range[i])
  max_index = Lidar_range[i].tolist().index(max_dist)
  corner_candidate = [max_index,max_dist]

  first_point = [0,mean([Lidar_range[i][0],Lidar_range[i][1]])]
  last_point = [60,mean([Lidar_range[i][60],Lidar_range[i][59]])]
  first_wall = np.polyfit(first_point, corner_candidate, 1) # y = mx+b    m is stored on [0], b is stored on [1]
  last_wall = np.polyfit(last_point, corner_candidate, 1)
  

  plt.show()
#
  if(len(locals_maximum[0])>=1):
    print("It's a Corner at ")
    print('at',max_index)

  else:
    print("Not a corner :(")

Lidar_range = data.iloc[:, np.arange(6,67,1)].values
print(Lidar_range)
px = data[0].values
py = data[1].values
th = data[2].values
t=1*10 #1sec times number of samples/second

angle = np.linspace(-30, 30, 61)

for i in range(len(Lidar_range[t])):
  Lidar_range_smooth = signal.savgol_filter(Lidar_range[i], window_length=9, polyorder=3, mode="nearest")
  plt.figure()
  plt.scatter(angle, Lidar_range[i], color='b')
  plt.title('Lidar measurements')
  plt.ylabel('r [m]')
  plt.xlabel('$beta$ [degree]')
  plt.plot(angle, Lidar_range_smooth, color ="red")
  plt.grid();
  plt.show()
  if((max(Lidar_range[i]) == Lidar_range[i][0]) or (max(Lidar_range[i]) == Lidar_range[i][60])):
    print("Not a corner")
  else:
    print("Possible a corner")
    max_index=np.argmax(Lidar_range[i]) #.index(max(Lidar_range[i]))
    
    x1=range(0,max_index+1,1)
    x2=range(max_index+1,61,1)

    y1=np.take(Lidar_range[i], x1)
    y2=np.take(Lidar_range[i], x2)

    plt.xlabel("X axis")
    plt.ylabel("Y axis")
    plt.plot(x1, y1, color ="red")
    plt.plot(x2, y2, color ="blue")
    plt.show()

corner_flags = []
for i in range(len(corner)):
  if corner[i] == [0,0]:
    corner_flags.append(0)
  else:
    corner_flags.append(1)


corners_alpha = []
corners_r = []
for i in range(len(corner)):
  if corner[i] == [0,0]:
    corners_alpha.append(99)
    corners_r.append(-1)
  else:  
    corners_alpha.append(corner_to_index(corner[i])-30)
    corners_r.append(sqrt(corner[i][0]**2+corner[i][1]**2))

print(corners_r)

sigma_sq_x = sigma_sq_y = sigma_sq_theta = 0.1

# Predict Function
def kf_predict(X, P, DX, Q):
    #Position Increment
    X = X + DX
    P = P + Q
    return(X,P)


# Predict Function
def kf_update(X, P, Y, H, R, HX):

    YHX = Y - HX
    while(YHX[1] > np.pi):
      YHX[1]=YHX[1] - 2*pi
    while(YHX[1] < -np.pi):
      YHX[1]=YHX[1] + 2*pi

    IS = H @ P @ H.T + R
    K = P @ H.T @ np.linalg.inv(IS)
    X = X + K @ YHX
    P = P - K @ IS @ K.T 

    return (X,P)

#Known Corner detection function
def knownCorner(p,lst):
  threshold=5
  flag=0
  if(len(lst) == 0):
    return flag
  else:
    for i in range(1,(len(lst)+1)):
      #Check if the point is close to any of the known corners
      dist=((p[0]-lst[i-1][0])**2 + (p[1]-lst[i-1][1])**2)**(0.5)
      if(dist<threshold):
        #If it is return the corner index as a flag
        flag = i
      #If it isn't the flag value will be 0
  return flag


#Get the data set infos

# Variable Initialization 

P = Q = np.array([[sigma_sq_x,0.0         ,              0.0], 
                 [0.0,         sigma_sq_y,              0.0], 
                 [0.0,         0.0,          sigma_sq_theta]])

X = np.array([[px[0]], 
              [py[0]], 
              [th[0]]])

DX = np.array([[0.0], 
               [0.0], 
               [0.0]])

Y = np.array([[0.0],  
              [0.0]])

H = np.array([[0.0,0.0,0.0],  
              [0.0,0.0,0.0]])

R = np.array([[5.0,0.0],  
              [0.0,5.0]])


n_features=0
Kncorner=[]
Kncorner_r_alpha = []
all_corners=[]
corners_x,corners_y=[],[]
p_x, p_y, p_theta = [],[],[]

for k in range(len(Lidar_range)):
  
  #Is it a corner?
  if corner_flags[k]:
    #Compute the Estimated Corner Position
    x_corner= X[0] + corners_r[k] * np.cos(X[2] + np.deg2rad(corners_alpha[k]))
    y_corner= X[1] + corners_r[k] * np.sin(X[2] + np.deg2rad(corners_alpha[k]))

    [c0]= x_corner
    [c1]= y_corner
    corner = np.array([[c0],[c1]])
    all_corners.append(corner)
    #Is it a known corner? (returns the corner number (1,2,3,4,...) or if it doesn't exist returns 0) 
    corner_n = knownCorner(corner,Kncorner)
    #print(corner_n)

    #If it isn't
    if(corner_n == 0):
      KC=[]
      Kncorner=[]

      #Add corner to X
      X=np.append(X,corner,axis=0)

      empty=np.zeros((2,1))
      DX = np.append(DX,empty,axis=0)

      tile_r=np.zeros((P.shape[0],2))
      tile_d=np.zeros((2,P.shape[0]+2))
      P = np.append(P,tile_r,axis=1)
      P = np.append(P,tile_d,axis=0)
      P[P.shape[0]-2,P.shape[1]-2] = P[0][0]
      P[P.shape[0]-1,P.shape[1]-1] = P[1][1]


      tile_r=np.zeros((Q.shape[0],2))
      tile_d=np.zeros((2,Q.shape[0]+2))
      Q = np.append(Q,tile_r,axis=1)
      Q = np.append(Q,tile_d,axis=0)
      Q[Q.shape[0]-2,Q.shape[1]-2] = sigma_sq_x
      Q[Q.shape[0]-1,Q.shape[1]-1] = sigma_sq_x


      #Increase the number of features
      n_features=n_features+1

      #Update the Kn corners list
      KC = X[3:,:]
      for i in range(1,KC.shape[0],2):
        [xc]=KC[i-1]
        [yc]=KC[i]
        c=np.array([[xc],[yc]])
        Kncorner.append(c)

    else:
      #Get the corner that is already known
      feature = Kncorner[corner_n-1]
      
      [xb]=feature[0]
      [yb]=feature[1]

      #Transform the corner to (r, alpha) in order to insert into Z
      [a]= np.arctan2(yb-X[1],xb-X[0]) - X[2]
      [r]= np.sqrt((xb-X[0])**2+(yb-X[1])**2)

      Z = np.array([[r],
                    [a]])
      
      r1=corners_r[k]
      a1=np.deg2rad(corners_alpha[k])

      Y = np.array([[r1],
                    [a1]])
      
       
      #Calculate Matrix H with that corner position
      [h11]= -(xb-X[0])/np.sqrt((xb-X[0])**2+(yb-X[1])**2)
      [h12]= -(yb-X[1])/np.sqrt((xb-X[0])**2+(yb-X[1])**2)
      h13= 0.0
      [h21]=  (yb-X[1])/((xb-X[0])**2+(yb-X[1])**2)
      [h22]= -(xb-X[0])/((xb-X[0])**2+(yb-X[1])**2)
      h23= -1.0

      #Calculate the values of the feature
      [f11]=  (xb-X[0])/np.sqrt(((xb-X[0])**2+(yb-X[1])**2))
      [f12]=  (yb-X[1])/np.sqrt(((xb-X[0])**2+(yb-X[1])**2))
      [f21]= -(yb-X[1])/((xb-X[0])**2+(yb-X[1])**2)
      [f22]=  (xb-X[0])/((xb-X[0])**2+(yb-X[1])**2)
      
      H = np.array([[h11,h12,h13],  
                    [h21,h22,h23]])
      
      F= np.array([[f11,f12],  
                   [f21,f22]])
      
      empty=np.zeros((2,2))

      for i in range(n_features):
        if(i+1 != corner_n):
          H = np.append(H,empty,axis=1)
        else:
          H = np.append(H,F,axis=1)
        

      X,P = kf_update(X, P, Y, H, R, Z)#mexi na identação desta celula

  p_x.append(X[0])
  p_y.append(X[1])
  p_theta.append(X[2])


  DX[0]=x_delta[k]
  DX[1]=y_delta[k]
  DX[2]=th_delta[k]
  X,P = kf_predict(X,P,DX,Q)

  fig, ax = plt.subplots(figsize=(7,7))
  ax.axis('equal')
  plt.xlim(-3,18)
  plt.ylim(-5,18)
  plt.plot(px, py, 'r.', ms=10)  #estimate position of the robot
  plt.plot(p_x, p_y, 'g.', ms=10)  #estimate position of the robot
  plt.scatter(border_x, border_y, color='b', label="Map borders plot")
  for i in range(len(Kncorner)):
    plt.scatter(Kncorner[i][0],Kncorner[i][1],color='orange')
  
  plt.grid()
  plt.title('2D Map');